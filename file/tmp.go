// gogo. A Golang toolbox.
// Copyright (C) 2019-2020 Yuan Gao
//
// This file is part of gogo.
//
// gogo is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

package file

import (
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

// Create a new temporary file in the directory dir, with given permission perm
// (before umask), for reading and writing.
// The filename is generated by taking pattern and adding a random string to
// the end. If pattern includes a "*", the random string replaces the last "*".
// If dir is empty, it uses os.TempDir() instead.
//
// Calling this function simultaneously will not choose the same file.
//
// The client can use f.Name() to find the path of the file.
// It is the client's responsibility to remove the file when no longer needed.
func Tmp(dir, pattern string, perm os.FileMode) (f *os.File, err error) {
	if dir == "" {
		dir = os.TempDir()
	}
	prefix, suffix := parseTmpPattern(pattern)
	r := uint32(time.Now().UnixNano() + int64(os.Getpid())*1000)
	for try := 0; try < 100; try++ {
		f, err = os.OpenFile(filepath.Join(dir,
			prefix+strconv.FormatUint(uint64(r), 36)+suffix),
			os.O_RDWR|os.O_CREATE|os.O_EXCL, perm)
		if err == nil || !os.IsExist(err) {
			return
		}
		r = r*1664525 + 1013904223 // constants from Numerical Recipes, for a linear congruential generator
	}
	return
}

// Create a new temporary directory in the directory dir, with given permission
// perm (before umask), and return the full name of the new directory.
// The directory name is generated by taking pattern and adding a random string
// to the end. If pattern includes a "*", the random string replaces the
// last "*".
// If dir is empty, it uses os.TempDir() instead.
//
// Calling this function simultaneously will not choose the same directory.
//
// It is the client's responsibility to remove the directory when no longer needed.
func TmpDir(dir, pattern string, perm os.FileMode) (name string, err error) {
	if dir == "" {
		dir = os.TempDir()
	}
	prefix, suffix := parseTmpPattern(pattern)
	r := uint32(time.Now().UnixNano() + int64(os.Getpid())*1000)
	for try := 0; try < 100; try++ {
		tmpName := filepath.Join(dir, prefix+strconv.FormatUint(uint64(r), 36)+suffix)
		err = os.Mkdir(tmpName, perm)
		if err == nil {
			name = tmpName
			return
		}
		if os.IsNotExist(err) {
			// It may because dir doesn't exist. Try to report dir doesn't exist.
			if _, err := os.Lstat(dir); os.IsNotExist(err) {
				return "", err
			}
		}
		if !os.IsExist(err) {
			return
		}
		r = r*1664525 + 1013904223 // constants from Numerical Recipes, for a linear congruential generator
	}
	return
}

func parseTmpPattern(pattern string) (prefix, suffix string) {
	if i := strings.LastIndex(pattern, "*"); i >= 0 {
		prefix, suffix = pattern[:i], pattern[i+1:]
	} else {
		prefix = pattern
	}
	return
}
